<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top-Down Racer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            background-color: #333; /* Dark background for the page */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Full viewport height */
            background: linear-gradient(45deg, #1a1a1a, #4a4a4a); /* Add gradient background */
        }
        canvas {
            display: block;
            border: 2px solid #666; /* Darker border for contrast */
            box-shadow: 0 0 20px rgba(0,0,0,0.5); /* Add subtle shadow effect */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <!-- Car Sprite Image (Base64 encoded for single HTML file) -->
    <!-- This is a simple red top-down car, facing upwards. -->
    <img id="carSprite" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAjCAYAAABvR7Y6AAAABmJLR0QA/wD/AP+AdzggAAAAtUlEQVRIx2P4DwQYGPg/oP/v37/vP7/7N0yAhkGGYVhw4CAzMP0DA+MPGhpGA0jA8AwMDB9m/3///j9wMQYGBq4MDAz/h4H7+Q8QJgx4/w8DAwMDD+fPfx+wMTAwMPIwMDD8P31gwPDv/wMMDAxg/Pz+gZGBAR/2vP+BgeG/s/T/oJGhgaGDkYGB4R8GBgb2f2BiYGBgYMDAwMBiQzUoGwY4DAwMWBgYAAB111V0xW5+76gAAAABJRU5ErkJggg==" style="display:none;">

    <script>
        // Game Constants
        const CANVAS_WIDTH = 900;
        const CANVAS_HEIGHT = 700;
        const CAR_WIDTH = 20;
        const CAR_HEIGHT = 35; // Car is taller than wide in top-down view
        const CAR_MAX_SPEED = 6; // Max forward speed (increased for more noticeable movement)
        const CAR_REVERSE_SPEED = 3; // Max reverse speed (increased)
        const CAR_ACCELERATION = 0.15; // Increased acceleration (more responsive)
        const CAR_FRICTION = 0.03; // Decreased friction to make movement more fluid
        const CAR_OFF_TRACK_FRICTION_MULTIPLIER = 0.6; // Reduces speed significantly off-track (more severe effect)
        const CAR_TURN_RATE = 0.05; // Radians per frame at max speed (increased for quicker turning)

        // Game Colors
        const TRACK_COLOR = '#444'; // Dark grey for the road
        const GRASS_COLOR = '#228B22'; // Forest green for off-track areas
        const CAR_COLOR = 'red';
        const CAR_FRONT_INDICATOR_COLOR = 'white';

        // Game Variables
        let canvas, ctx;
        let carSpriteImage; // Variable to hold the loaded car image element

        let car = {
            x: CANVAS_WIDTH / 2,
            y: CANVAS_HEIGHT / 2 + 100, // Starting position on the track
            angle: -Math.PI / 2, // Facing upwards (0 is right, Math.PI/2 is down)
            speed: 0,
            accelerationInput: 0, // -1 for reverse, 0 for none, 1 for forward
            turnInput: 0 // -1 for left, 0 for none, 1 for right
        };

        let keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };

        // Track Definition (for a rounded oval course)
        // These points define the outer and inner boundaries of the track.
        // The `TRACK_CORNER_RADIUS` will round the corners.
        const TRACK_PATH_POINTS_OUTER = [
            { x: 300, y: 100 }, { x: 600, y: 100 }, // Top straight segment
            { x: 800, y: 350 }, // Right side midpoint for rounding
            { x: 600, y: 600 }, { x: 300, y: 600 }, // Bottom straight segment
            { x: 100, y: 350 }  // Left side midpoint for rounding
        ];
        const TRACK_PATH_POINTS_INNER = [
            { x: 350, y: 200 }, { x: 550, y: 200 }, // Top straight segment
            { x: 650, y: 350 }, // Right side midpoint for rounding
            { x: 550, y: 500 }, { x: 350, y: 500 }, // Bottom straight segment
            { x: 250, y: 350 }  // Left side midpoint for rounding
        ];
        const TRACK_CORNER_RADIUS = 70; // Radius for the rounded corners of the track

        // Off-screen canvas for precise collision detection
        let trackCollisionCanvas;
        let trackCollisionCtx;
        // Define specific RGB values for road and grass on the collision map
        const TRACK_ROAD_COLOR_COLLISION = { r: 0, g: 0, b: 0, a: 255 };     // Pure black for road on collision map
        const TRACK_GRASS_COLOR_COLLISION = { r: 255, g: 255, b: 255, a: 255 }; // Pure white for grass on collision map

        /**
         * Draws a closed, rounded path on a given canvas context.
         * This function helps create the smooth oval track shape.
         * @param {CanvasRenderingContext2D} context - The 2D rendering context to draw on.
         * @param {Array<Object>} points - An array of {x, y} objects defining the main corners of the path.
         * @param {number} radius - The radius for rounding the corners.
         */
        function drawRoundedPath(context, points, radius) {
            if (points.length < 2) return;

            context.beginPath();
            // Start at the first point after a small offset to allow arcTo to draw to it
            context.moveTo(points[0].x + (points[1].x - points[0].x > 0 ? radius : -radius), points[0].y); 

            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length]; // Current corner point
                const p3 = points[(i + 2) % points.length]; // Next point after the corner

                context.arcTo(p2.x, p2.y, p3.x, p3.y, radius);
            }
            context.closePath();
        }

        /**
         * Initialises the off-screen canvas for track collision detection.
         * This canvas is drawn only once at startup and used to quickly check if the car is on the road.
         */
        function setupTrackCollisionMap() {
            trackCollisionCanvas = document.createElement('canvas');
            trackCollisionCanvas.width = CANVAS_WIDTH;
            trackCollisionCanvas.height = CANVAS_HEIGHT;
            trackCollisionCtx = trackCollisionCanvas.getContext('2d');

            // 1. Draw grass area (white) on the collision map
            trackCollisionCtx.fillStyle = `rgb(${TRACK_GRASS_COLOR_COLLISION.r},${TRACK_GRASS_COLOR_COLLISION.g},${TRACK_GRASS_COLOR_COLLISION.b})`;
            trackCollisionCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 2. Draw road area (black) on the collision map
            trackCollisionCtx.fillStyle = `rgb(${TRACK_ROAD_COLOR_COLLISION.r},${TRACK_ROAD_COLOR_COLLISION.g},${TRACK_ROAD_COLOR_COLLISION.b})`;
            
            // Draw the outer path of the track
            trackCollisionCtx.beginPath();
            drawRoundedPath(trackCollisionCtx, TRACK_PATH_POINTS_OUTER, TRACK_CORNER_RADIUS);
            
            // Draw the inner path (hole) of the track
            const reversedInnerPoints = [...TRACK_PATH_POINTS_INNER].reverse();
            drawRoundedPath(trackCollisionCtx, reversedInnerPoints, TRACK_CORNER_RADIUS);
            
            trackCollisionCtx.closePath();
            trackCollisionCtx.fill('evenodd');
        }

        /**
         * Determines if the car's current position is on the defined track by checking the pixel color
         * at the car's center on the off-screen collision map.
         * @returns {boolean} True if the car is on the track (road color), false otherwise (grass color or out of bounds).
         */
        function isCarOnTrack() {
            // Get the car's center coordinates, rounded to integers for pixel sampling
            const carCenterX = Math.floor(car.x);
            const carCenterY = Math.floor(car.y);

            // Check if the car's center is within the canvas bounds
            if (carCenterX < 0 || carCenterX >= CANVAS_WIDTH || carCenterY < 0 || carCenterY >= CANVAS_HEIGHT) {
                return false;
            }

            // Get the pixel data (RGBA) at the car's center from the collision map
            const pixel = trackCollisionCtx.getImageData(carCenterX, carCenterY, 1, 1).data;
            
            // Compare the pixel color to the defined road color
            return pixel[0] === TRACK_ROAD_COLOR_COLLISION.r &&
                   pixel[1] === TRACK_ROAD_COLOR_COLLISION.g &&
                   pixel[2] === TRACK_ROAD_COLOR_COLLISION.b &&
                   pixel[3] === TRACK_ROAD_COLOR_COLLISION.a;
        }

        // Initialization function called when the window loads
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            carSpriteImage = document.getElementById('carSprite');

            // Setup the off-screen track collision map before starting the game loop
            setupTrackCollisionMap();

            // Set up event listeners for keyboard input
            window.addEventListener('keydown', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = true;
                    e.preventDefault(); // Prevent default browser actions like scrolling
                }
            });
            window.addEventListener('keyup', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = false;
                }
            });

            // Start the main game loop
            gameLoop();
        }

        // The main game loop, called continuously using requestAnimationFrame
        function gameLoop() {
            update(); // Update game state (car position, speed, etc.)
            draw();   // Draw everything on the canvas
            requestAnimationFrame(gameLoop); // Request the next frame
        }

        // Updates the game state for each frame
        function update() {
            // Handle acceleration/braking input
            if (keys.ArrowUp) {
                car.accelerationInput = 1;
            } else if (keys.ArrowDown) {
                car.accelerationInput = -1;
            } else {
                car.accelerationInput = 0;
            }

            // Apply acceleration
            car.speed += car.accelerationInput * CAR_ACCELERATION;

            // Apply friction
            if (car.speed > 0) {
                car.speed = Math.max(0, car.speed - CAR_FRICTION);
            } else if (car.speed < 0) {
                car.speed = Math.min(0, car.speed + CAR_FRICTION);
            }

            // Clamp speed within max forward/reverse limits
            car.speed = Math.max(-CAR_REVERSE_SPEED, Math.min(CAR_MAX_SPEED, car.speed));

            // Handle turning input
            car.turnInput = 0;
            if (keys.ArrowLeft) {
                car.turnInput = -1;
            }
            if (keys.ArrowRight) {
                car.turnInput = 1;
            }

            // Apply turning (only when moving)
            if (Math.abs(car.speed) > 0.1) { // Only allow turning if car has some speed
                // Turning rate scales with speed: faster turning at higher speeds
                // Use Math.sign(car.speed) to ensure turning direction is correct for reverse
                car.angle += car.turnInput * CAR_TURN_RATE * (Math.abs(car.speed) / CAR_MAX_SPEED);
            }


            // Update car position based on speed and angle
            car.x += car.speed * Math.cos(car.angle);
            car.y += car.speed * Math.sin(car.angle);

            // Collision Detection with Track
            if (!isCarOnTrack()) {
                // If off track, apply heavy friction to slow down
                car.speed *= CAR_OFF_TRACK_FRICTION_MULTIPLIER;
                if (Math.abs(car.speed) < 0.1) { // Stop completely if very slow off-track
                    car.speed = 0;
                }
            }
        }

        // Draws all game elements on the canvas
        function draw() {
            // Clear the entire canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 1. Draw Grass (entire canvas initially)
            ctx.fillStyle = GRASS_COLOR;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 2. Draw Track (Road)
            ctx.fillStyle = TRACK_COLOR;
            ctx.beginPath();
            // Draw the outer path of the track
            drawRoundedPath(ctx, TRACK_PATH_POINTS_OUTER, TRACK_CORNER_RADIUS);
            
            // Draw the inner path to create the hole in the track
            const reversedInnerPoints = [...TRACK_PATH_POINTS_INNER].reverse();
            drawRoundedPath(ctx, reversedInnerPoints, TRACK_CORNER_RADIUS);

            ctx.closePath();
            ctx.fill('evenodd');

            // 3. Draw Car
            ctx.save();
            ctx.translate(car.x, car.y);
            ctx.rotate(car.angle + Math.PI / 2); // Adjust rotation for sprite orientation
            ctx.drawImage(carSpriteImage, -CAR_WIDTH / 2, -CAR_HEIGHT / 2, CAR_WIDTH, CAR_HEIGHT);
            ctx.restore();
        }

        // Attach the initialization function to the window's load event
        window.onload = init;
    </script>
</body>
</html>
