<!DOCTYPE html>
<html>
<head>
    <title>Phaser Racer Pro - Refactored</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
    </style>
</head>
<body>
    <script>
        window.onload = function() {

            // --- CONSTANTS ---
            const TRACK_WIDTH = 240; // Double the original width
            const OUTER_WIDTH = 5600; // Changed from 2800 to 5600
            const OUTER_HEIGHT = 3200; // Changed from 1600 to 3200
            const CAR_FRICTION = {
                NORMAL: 0.05,
                GRASS: 0.3
            };
            const CAR_CONTROLS = {
                ACCELERATION: 0.0075, // Half the original speed
                STEERING: 0.015 // Half the original steering
            };

            // --- TRACK CLASS ---
            class Track {
                constructor(scene) {
                    this.scene = scene;
                    this.graphics = this.scene.add.graphics();
                    
                    const centerX = OUTER_WIDTH;
                    const centerY = OUTER_HEIGHT;

                    // Create geometry
                    this.outerPolygon = this.createTrackPolygon(centerX, centerY, OUTER_WIDTH, OUTER_HEIGHT);
                    this.innerPolygon = this.createTrackPolygon(centerX, centerY, OUTER_WIDTH - (TRACK_WIDTH * 2), OUTER_HEIGHT - (TRACK_WIDTH * 2));

                    this.startPosition = {
                        x: centerX - (OUTER_WIDTH * 0.25),
                        y: centerY + (OUTER_HEIGHT * 0.25)
                    };
                }

                createTrackPolygon(centerX, centerY, width, height) {
                    // Create a 'P' shape rotated 90 degrees clockwise as a closed circuit
                    // The 'P' will be oriented horizontally with rounded corners
    
                    const points = [];
    
                    // Scale factors for the P shape
                    const w = width * 0.7; // Use more of the available width
                    const h = height * 0.7; // Use more of the available height
                    const stemWidth = w * 0.25;
                    const topHeight = h * 0.35;
                    const cornerRadius = Math.min(stemWidth * 0.3, topHeight * 0.3);
    
                    // Starting point (bottom left of the stem)
                    const startX = centerX - w/2;
                    const startY = centerY + h/2;
    
                    // Bottom left corner (rounded)
                    this.addRoundedCorner(points, startX + cornerRadius, startY, cornerRadius, 180, 270);
    
                    // Bottom horizontal line
                    points.push(new Phaser.Math.Vector2(startX + stemWidth - cornerRadius, startY));
    
                    // Bottom right of stem (rounded corner)
                    this.addRoundedCorner(points, startX + stemWidth - cornerRadius, startY - cornerRadius, cornerRadius, 270, 360);
    
                    // Right side of stem going up
                    points.push(new Phaser.Math.Vector2(startX + stemWidth, centerY - h/2 + topHeight + cornerRadius));
    
                    // Corner before middle horizontal
                    this.addRoundedCorner(points, startX + stemWidth + cornerRadius, centerY - h/2 + topHeight + cornerRadius, cornerRadius, 180, 270);
    
                    // Middle horizontal line going right
                    points.push(new Phaser.Math.Vector2(startX + w - stemWidth - cornerRadius, centerY - h/2 + topHeight));
    
                    // Top right corner of middle section
                    this.addRoundedCorner(points, startX + w - stemWidth - cornerRadius, centerY - h/2 + topHeight - cornerRadius, cornerRadius, 0, 90);
    
                    // Right side of top section going up
                    points.push(new Phaser.Math.Vector2(startX + w - stemWidth, centerY - h/2 + cornerRadius));
    
                    // Top right corner
                    this.addRoundedCorner(points, startX + w - stemWidth - cornerRadius, centerY - h/2 + cornerRadius, cornerRadius, 270, 360);
    
                    // Top horizontal line
                    points.push(new Phaser.Math.Vector2(startX + cornerRadius, centerY - h/2));
    
                    // Top left corner
                    this.addRoundedCorner(points, startX + cornerRadius, centerY - h/2 + cornerRadius, cornerRadius, 180, 270);
    
                    // Left side going down
                    points.push(new Phaser.Math.Vector2(startX, startY - cornerRadius));
    
                    return new Phaser.Geom.Polygon(points);
                }

                addRoundedCorner(points, centerX, centerY, radius, startAngle, endAngle) {
                    const steps = 8; // Number of points for the curve
                    for (let i = 0; i <= steps; i++) {
                        const angle = Phaser.Math.DegToRad(startAngle + (endAngle - startAngle) * (i / steps));
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        points.push(new Phaser.Math.Vector2(x, y));
                    }
                }

                draw() {
                    // Tarmac
                    this.graphics.fillStyle(0x444444);
                    this.graphics.fillPoints(this.outerPolygon.points, true);

                    // Inner grass
                    this.graphics.fillStyle(0x228B22);
                    this.graphics.fillPoints(this.innerPolygon.points, true);
                }

                isOnTrack(point) {
                    return Phaser.Geom.Polygon.ContainsPoint(this.outerPolygon, point) && 
                           !Phaser.Geom.Polygon.ContainsPoint(this.innerPolygon, point);
                }
            }

            // --- CAR CLASS ---
            class Car {
                static preload(scene) {
                    let carGraphics = scene.make.graphics({x: 0, y: 0, add: false});
                    carGraphics.clear();

                    // Chassis & Nose
                    carGraphics.fillStyle(0xFF1801);
                    carGraphics.beginPath();
                    carGraphics.moveTo(85, 25);
                    carGraphics.lineTo(70, 15);
                    carGraphics.lineTo(25, 15);
                    carGraphics.lineTo(25, 35);
                    carGraphics.lineTo(70, 35);
                    carGraphics.closePath();
                    carGraphics.fillPath();

                    // Sidepods
                    carGraphics.fillRect(30, 10, 30, 5);
                    carGraphics.fillRect(30, 35, 30, 5);
                    // Cockpit
                    carGraphics.fillStyle(0x222222);
                    carGraphics.fillRect(50, 20, 15, 10);
                    // Wings
                    carGraphics.fillStyle(0x333333);
                    carGraphics.fillRect(75, 5, 10, 40);
                    carGraphics.fillRect(5, 5, 10, 40);
                    carGraphics.fillRect(5, 15, 30, 5);
                    carGraphics.fillRect(5, 30, 30, 5);
                    // Wheels
                    carGraphics.fillStyle(0x111111);
                    carGraphics.fillRect(60, 5, 10, 5);
                    carGraphics.fillRect(60, 40, 10, 5);
                    carGraphics.fillRect(22.5, 2.5, 15, 5);
                    carGraphics.fillRect(22.5, 42.5, 15, 5);

                    // Outlines
                    carGraphics.lineStyle(2, 0x000000);
                    carGraphics.beginPath();
                    carGraphics.moveTo(85, 25);
                    carGraphics.lineTo(70, 15);
                    carGraphics.lineTo(25, 15);
                    carGraphics.lineTo(25, 35);
                    carGraphics.lineTo(70, 35);
                    carGraphics.closePath();
                    carGraphics.strokePath();
                    carGraphics.strokeRect(30, 10, 30, 5);
                    carGraphics.strokeRect(30, 35, 30, 5);
                    carGraphics.strokeRect(50, 20, 15, 10);
                    carGraphics.strokeRect(75, 5, 10, 40);
                    carGraphics.strokeRect(5, 5, 10, 40);
                    carGraphics.strokeRect(5, 15, 30, 5);
                    carGraphics.strokeRect(5, 30, 30, 5);
                    carGraphics.strokeRect(60, 5, 10, 5);
                    carGraphics.strokeRect(60, 40, 10, 5);
                    carGraphics.strokeRect(22.5, 2.5, 15, 5);
                    carGraphics.strokeRect(22.5, 42.5, 15, 5);

                    carGraphics.generateTexture('car_texture', 90, 50); // Reverted to original size
                }

                constructor(scene, startPosition) {
                    console.log('Car constructor called with startPosition:', startPosition);
                    this.scene = scene;
                    this.sprite = scene.matter.add.image(startPosition.x, startPosition.y, 'car_texture')
                        .setAngle(0)
                        .setFrictionAir(CAR_FRICTION.NORMAL)
                        .setMass(10)
                        .setDepth(10); // Set a high depth to ensure it's drawn on top
                    console.log('Car sprite created at:', this.sprite.x, this.sprite.y);
                    
                    this.emitter = scene.add.particles(0, 0, 'white_pixel', {
                        speed: 10,
                        scale: { start: 0.5, end: 0 },
                        blendMode: 'ADD',
                        lifespan: 400
                    });
                    this.emitter.startFollow(this.sprite);
                }

                update(cursors) {
                    if (cursors.left.isDown) {
                        this.sprite.setAngularVelocity(-CAR_CONTROLS.STEERING);
                    } else if (cursors.right.isDown) {
                        this.sprite.setAngularVelocity(CAR_CONTROLS.STEERING);
                    } else {
                        this.sprite.setAngularVelocity(0);
                    }

                    if (cursors.up.isDown) {
                        const force = new Phaser.Math.Vector2(Math.cos(this.sprite.rotation), Math.sin(this.sprite.rotation)).scale(CAR_CONTROLS.ACCELERATION);
                        this.sprite.applyForce(force);
                    }
                }

                setOffTrack(isOffTrack) {
                    if (isOffTrack) {
                        this.sprite.setFrictionAir(CAR_FRICTION.GRASS);
                        this.emitter.stop();
                    } else {
                        this.sprite.setFrictionAir(CAR_FRICTION.NORMAL);
                        if (this.sprite.body.speed > 0.1) {
                            this.emitter.start();
                        } else {
                            this.emitter.stop();
                        }
                    }
                }
            }

            // --- GAME SCENE ---
            class GameScene extends Phaser.Scene {
                constructor() {
                    super({ key: 'GameScene' });
                }

                preload() {
                    Car.preload(this);
                    this.textures.generate('white_pixel', { data: ['#'], pixelWidth: 2, pixelHeight: 2 });
                }

                create() {
                    // Grass background
                    this.add.rectangle(
                        OUTER_WIDTH, 
                        OUTER_HEIGHT, 
                        OUTER_WIDTH * 2, 
                        OUTER_HEIGHT * 2, 
                        0x228B22
                    );

                    this.track = new Track(this);
                    this.track.draw();

                    this.car = new Car(this, this.track.startPosition);
                    console.log('Car start position:', this.track.startPosition);
                    console.log('Car sprite final position:', this.car.sprite.x, this.car.sprite.y);
                    console.log('Track outer polygon points:', this.track.outerPolygon.points);
                    console.log('Game config width:', this.game.config.width, 'height:', this.game.config.height);
                    
                    // Set the camera's position to the car's initial position
                    this.cameras.main.setScroll(this.car.sprite.x - this.game.config.width / 2, this.car.sprite.y - this.game.config.height / 2);

                    this.cursors = this.input.keyboard.createCursorKeys();
                    
                    this.cameras.main.startFollow(this.car.sprite, true, 0.1, 0.1); // Adjusted lerping for smoother follow
                    this.cameras.main.setBounds(0, 0, OUTER_WIDTH * 2, OUTER_HEIGHT * 2);
                    this.cameras.main.setZoom(1.2); // Reverted to original as requested
                    console.log('Camera scroll:', this.cameras.main.scrollX, this.cameras.main.scrollY);

                    this.debugText = this.add.text(10, 10, '', { font: '16px Arial', fill: '#fff' }).setDepth(1);
                }

                update() {
                    this.car.update(this.cursors);

                    const onTrack = this.track.isOnTrack(this.car.sprite);
                    this.car.setOffTrack(!onTrack);

                    // Update UI
                    this.debugText.setPosition(this.cameras.main.scrollX + 10, this.cameras.main.scrollY + 10);
                    this.debugText.setText([
                        `Speed: ${this.car.sprite.body.speed.toFixed(2)}`,
                        onTrack ? 'On Track' : 'Off Track!'
                    ]);
                }
            }

            // --- GAME CONFIGURATION ---
            const config = {
                type: Phaser.AUTO,
                width: 1200, // Viewport width
                height: 800,  // Viewport height
                physics: {
                    default: 'matter',
                    matter: {
                        gravity: { y: 0 },
                        debug: false // Re-enabled for debugging
                    }
                },
                scene: [GameScene]
            };

            // --- START GAME ---
            const game = new Phaser.Game(config);
        };
    </script>
</body>
</html>
