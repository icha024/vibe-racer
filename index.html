<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top-Down Racer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            background-color: #333; /* Dark background for the page */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Full viewport height */
        }
        canvas {
            display: block;
            border: 2px solid #555; /* Optional border for the canvas */
            background-color: #666; /* Default background for canvas if no grass is drawn */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Game Constants
        const CANVAS_WIDTH = 900;
        const CANVAS_HEIGHT = 700;
        const CAR_WIDTH = 20;
        const CAR_HEIGHT = 35; // Car is taller than wide in top-down view
        const CAR_MAX_SPEED = 5; // Max forward speed
        const CAR_REVERSE_SPEED = 2.5; // Max reverse speed
        const CAR_ACCELERATION = 0.1;
        const CAR_BRAKING = 0.2;
        const CAR_FRICTION = 0.05; // Constant friction applied to slow down
        const CAR_OFF_TRACK_FRICTION_MULTIPLIER = 0.8; // Reduces speed significantly off-track
        const CAR_TURN_RATE = 0.04; // Radians per frame at max speed

        // Game Colors
        const TRACK_COLOR = '#444'; // Dark grey for the road
        const GRASS_COLOR = '#228B22'; // Forest green for off-track areas
        const CAR_COLOR = 'red';
        const CAR_FRONT_INDICATOR_COLOR = 'white';

        // Game Variables
        let canvas, ctx;
        let car = {
            x: CANVAS_WIDTH / 2,
            y: CANVAS_HEIGHT / 2 + 100, // Starting position on the track
            angle: -Math.PI / 2, // Facing upwards (0 is right, Math.PI/2 is down)
            speed: 0,
            accelerationInput: 0, // -1 for reverse, 0 for none, 1 for forward
            turnInput: 0 // -1 for left, 0 for none, 1 for right
        };

        let keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };

        // Track Definition (Rectangular track with an inner rectangular hole)
        // This creates a simple "donut" shaped track.
        const trackBounds = {
            outer: { xMin: 150, yMin: 100, xMax: 750, yMax: 600 },
            inner: { xMin: 250, yMin: 200, xMax: 650, yMax: 500 }
        };

        /**
         * Checks if a point is within a given rectangular boundary.
         * @param {number} x - The x-coordinate of the point.
         * @param {number} y - The y-coordinate of the point.
         * @param {object} rect - An object with xMin, yMin, xMax, yMax properties.
         * @returns {boolean} True if the point is inside the rectangle, false otherwise.
         */
        function isPointInRect(x, y, rect) {
            return x >= rect.xMin && x <= rect.xMax &&
                   y >= rect.yMin && y <= rect.yMax;
        }

        /**
         * Determines if the car's current position is on the defined track.
         * The track is defined as the area inside the outer rectangle but outside the inner rectangle.
         * @returns {boolean} True if the car is on the track, false otherwise.
         */
        function isCarOnTrack() {
            const carCenterX = car.x;
            const carCenterY = car.y;

            const insideOuter = isPointInRect(carCenterX, carCenterY, trackBounds.outer);
            const insideInner = isPointInRect(carCenterX, carCenterY, trackBounds.inner);

            return insideOuter && !insideInner;
        }

        // Initialization function called when the window loads
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            // Set up event listeners for keyboard input
            window.addEventListener('keydown', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = true;
                    e.preventDefault(); // Prevent default browser actions like scrolling
                }
            });
            window.addEventListener('keyup', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    keys[e.key] = false;
                }
            });

            // Start the main game loop
            gameLoop();
        }

        // The main game loop, called continuously using requestAnimationFrame
        function gameLoop() {
            update(); // Update game state (car position, speed, etc.)
            draw();   // Draw everything on the canvas
            requestAnimationFrame(gameLoop); // Request the next frame
        }

        // Updates the game state for each frame
        function update() {
            // Handle acceleration/braking input
            if (keys.ArrowUp) {
                car.accelerationInput = 1;
            } else if (keys.ArrowDown) {
                car.accelerationInput = -1;
            } else {
                car.accelerationInput = 0;
            }

            // Apply acceleration
            car.speed += car.accelerationInput * CAR_ACCELERATION;

            // Apply friction
            if (car.speed > 0) {
                car.speed = Math.max(0, car.speed - CAR_FRICTION);
            } else if (car.speed < 0) {
                car.speed = Math.min(0, car.speed + CAR_FRICTION);
            }

            // Clamp speed within max forward/reverse limits
            car.speed = Math.max(-CAR_REVERSE_SPEED, Math.min(CAR_MAX_SPEED, car.speed));

            // Handle turning input
            car.turnInput = 0;
            if (keys.ArrowLeft) {
                car.turnInput = -1;
            }
            if (keys.ArrowRight) {
                car.turnInput = 1;
            }

            // Apply turning (only when moving)
            if (Math.abs(car.speed) > 0.1) { // Only allow turning if car has some speed
                // Turning rate scales with speed: faster turning at higher speeds
                // Use Math.sign(car.speed) to ensure turning direction is correct for reverse
                car.angle += car.turnInput * CAR_TURN_RATE * (Math.abs(car.speed) / CAR_MAX_SPEED);
            }


            // Update car position based on speed and angle
            car.x += car.speed * Math.cos(car.angle);
            car.y += car.speed * Math.sin(car.angle);

            // Collision Detection with Track
            if (!isCarOnTrack()) {
                // If off track, apply heavy friction to slow down
                car.speed *= CAR_OFF_TRACK_FRICTION_MULTIPLIER;
                if (Math.abs(car.speed) < 0.1) { // Stop completely if very slow off-track
                    car.speed = 0;
                }
            }
        }

        // Draws all game elements on the canvas
        function draw() {
            // Clear the entire canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 1. Draw Grass (entire canvas initially)
            ctx.fillStyle = GRASS_COLOR;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // 2. Draw Track (Road)
            ctx.fillStyle = TRACK_COLOR;
            ctx.beginPath();
            // Draw outer rectangle (clockwise)
            ctx.moveTo(trackBounds.outer.xMin, trackBounds.outer.yMin);
            ctx.lineTo(trackBounds.outer.xMax, trackBounds.outer.yMin);
            ctx.lineTo(trackBounds.outer.xMax, trackBounds.outer.yMax);
            ctx.lineTo(trackBounds.outer.xMin, trackBounds.outer.yMax);
            ctx.lineTo(trackBounds.outer.xMin, trackBounds.outer.yMin); // Close outer path

            // Draw inner rectangle (counter-clockwise to create a "hole" effect)
            ctx.moveTo(trackBounds.inner.xMin, trackBounds.inner.yMin);
            ctx.lineTo(trackBounds.inner.xMin, trackBounds.inner.yMax);
            ctx.lineTo(trackBounds.inner.xMax, trackBounds.inner.yMax);
            ctx.lineTo(trackBounds.inner.xMax, trackBounds.inner.yMin);
            ctx.lineTo(trackBounds.inner.xMin, trackBounds.inner.yMin); // Close inner path
            ctx.closePath(); // Ensure path is closed (important for fillRule)
            ctx.fill('evenodd'); // Use 'evenodd' fill rule to create the hole

            // 3. Draw Car
            ctx.save(); // Save the current canvas state (translation, rotation)

            // Translate and rotate the canvas to the car's position and angle
            ctx.translate(car.x, car.y);
            ctx.rotate(car.angle);

            // Draw the car body (red rectangle centered on its origin)
            ctx.fillStyle = CAR_COLOR;
            ctx.fillRect(-CAR_WIDTH / 2, -CAR_HEIGHT / 2, CAR_WIDTH, CAR_HEIGHT);

            // Draw a small white rectangle at the 'front' of the car
            ctx.fillStyle = CAR_FRONT_INDICATOR_COLOR;
            ctx.fillRect(-CAR_WIDTH / 4, -CAR_HEIGHT / 2, CAR_WIDTH / 2, CAR_HEIGHT / 4);

            ctx.restore(); // Restore the canvas state to what it was before drawing the car
        }

        // Attach the initialization function to the window's load event
        window.onload = init;
    </script>
</body>
</html>
