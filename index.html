<!DOCTYPE html>
<html>
<head>
    <title>Phaser Racer Pro</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
    </style>
</head>
<body>
    <script>
        window.onload = function() {
            // --- GAME CONFIGURATION ---
            const config = {
                type: Phaser.AUTO,
                width: 900,
                height: 700,
                physics: {
                    default: 'matter',
                    matter: {
                        gravity: { y: 0 },
                        debug: true
                    }
                },
                scene: {
                    preload: preload,
                    create: create,
                    update: update
                }
            };

            // --- GLOBAL VARIABLES ---
            const game = new Phaser.Game(config);
            let car, cursors, outerTrackBody, innerTrackBody, outerTrackPolygon, innerTrackPolygon;
            const normalFriction = 0.05;
            const grassFriction = 0.3;

            // --- SCENE FUNCTIONS ---
            function preload() {
                let carGraphics = this.make.graphics({x: 0, y: 0, add: false});
                carGraphics.clear();

                // Chassis & Nose - Combined for a sleek arrow shape
                carGraphics.fillStyle(0xFF1801); // Main body color (e.g., Ferrari red)
                carGraphics.beginPath();
                carGraphics.moveTo(85, 25);  // Nose tip (longer)
                carGraphics.lineTo(70, 15);  // Front left point (sharper nose angle)
                carGraphics.lineTo(25, 15);  // Rear left chassis (shorter body)
                carGraphics.lineTo(25, 35);  // Rear right chassis (shorter body)
                carGraphics.lineTo(70, 35);  // Front right point (sharper nose angle)
                carGraphics.closePath();
                carGraphics.fillPath();

                // Sidepods (subtly wider sections)
                carGraphics.fillRect(30, 10, 30, 5); // Left sidepod
                carGraphics.fillRect(30, 35, 30, 5); // Right sidepod

                // Cockpit / Airbox
                carGraphics.fillStyle(0x222222); // Darker for cockpit
                carGraphics.fillRect(50, 20, 15, 10); // Central cockpit area

                // Front Wing (wide and thin)
                carGraphics.fillStyle(0x333333); // Dark grey for carbon fibre
                carGraphics.fillRect(75, 5, 10, 40); // Main plane (simulated with a rectangle)

                // Rear Wing (T-shape with endplates, distinct from body)
                carGraphics.fillRect(5, 5, 10, 40); // Vertical endplates
                carGraphics.fillRect(5, 15, 30, 5); // Upper horizontal element
                carGraphics.fillRect(5, 30, 30, 5); // Lower horizontal element

                // Wheels (Rectangular/squared off for top-down view)
                carGraphics.fillStyle(0x111111); // Black for tires
                // Front Wheels (narrower)
                carGraphics.fillRect(60, 5, 10, 5); // Front-left wheel
                carGraphics.fillRect(60, 40, 10, 5); // Front-right wheel
                // Rear Wheels (wider)
                carGraphics.fillRect(22.5, 2.5, 15, 5); // Rear-left wheel
                carGraphics.fillRect(22.5, 42.5, 15, 5); // Rear-right wheel

                // Add outline for better definition - draw after fill to ensure visibility
                carGraphics.lineStyle(2, 0x000000); // Black outline for clarity
                
                // Outline for Chassis & Nose
                carGraphics.beginPath();
                carGraphics.moveTo(85, 25);
                carGraphics.lineTo(70, 15);
                carGraphics.lineTo(25, 15);
                carGraphics.lineTo(25, 35);
                carGraphics.lineTo(70, 35);
                carGraphics.closePath();
                carGraphics.strokePath();

                // Outline for Sidepods
                carGraphics.strokeRect(30, 10, 30, 5);
                carGraphics.strokeRect(30, 35, 30, 5);
                
                // Outline for Cockpit
                carGraphics.strokeRect(50, 20, 15, 10);

                // Outline for Front Wing
                carGraphics.strokeRect(75, 5, 10, 40);

                // Outline for Rear Wing
                carGraphics.strokeRect(5, 5, 10, 40);
                carGraphics.strokeRect(5, 15, 30, 5);
                carGraphics.strokeRect(5, 30, 30, 5);

                // Outline for Wheels
                carGraphics.strokeRect(60, 5, 10, 5);
                carGraphics.strokeRect(60, 40, 10, 5);
                carGraphics.strokeRect(22.5, 2.5, 15, 5);
                carGraphics.strokeRect(22.5, 42.5, 15, 5);

                // Generate texture. Adjust dimensions to encompass all parts
                carGraphics.generateTexture('car_texture', 90, 50);
                this.textures.generate('white_pixel', { data: ['#'], pixelWidth: 2, pixelHeight: 2 });
            }

            function create() {
                this.debugText = this.add.text(10, 10, '', { font: '16px Arial', fill: '#fff' }).setDepth(1);
                
                createTrack.call(this);
                
                // Start car inside the track, rotated to face up
                car = this.matter.add.image(450, 575, 'car_texture')
                    .setAngle(-90) // Rotate the right-pointing graphic to face up
                    .setFrictionAir(normalFriction)
                    .setMass(10);

                cursors = this.input.keyboard.createCursorKeys();
                
                this.cameras.main.startFollow(car, true, 0.08, 0.08);
                this.cameras.main.setZoom(1.5);
                
                this.emitter = this.add.particles(0, 0, 'white_pixel', {
                    speed: 10,
                    scale: { start: 0.5, end: 0 },
                    blendMode: 'ADD',
                    lifespan: 400
                });
                this.emitter.startFollow(car);
                this.emitter.stop();
            }

            function createTrack() {
                // Define the vertices for the outer and inner track polygons.
                // These points define a more challenging, winding track with approximated curves.
                const outerVertices = [
                    { x: 200, y: 100 }, { x: 700, y: 100 }, // Top straight
                    { x: 800, y: 150 }, { x: 850, y: 250 }, // Top-right curve points
                    { x: 850, y: 450 }, { x: 800, y: 550 }, // Right straight + curve points
                    { x: 700, y: 600 }, { x: 200, y: 600 }, // Bottom straight
                    { x: 100, y: 550 }, { x: 50, y: 450 },  // Bottom-left curve points
                    { x: 50, y: 250 }, { x: 100, y: 150 }   // Left straight + curve points
                ];

                const innerVertices = [
                    { x: 250, y: 150 }, { x: 650, y: 150 }, // Top straight (inner)
                    { x: 700, y: 190 }, { x: 750, y: 250 }, // Top-right curve points (inner)
                    { x: 750, y: 450 }, { x: 700, y: 510 }, // Right straight + curve points (inner)
                    { x: 650, y: 550 }, { x: 250, y: 550 }, // Bottom straight (inner)
                    { x: 200, y: 510 }, { x: 150, y: 450 }, // Bottom-left curve points (inner)
                    { x: 150, y: 250 }, { x: 200, y: 190 }  // Left straight + curve points (inner)
                ];

                // Draw the grass background for the entire scene
                this.add.rectangle(450, 350, 900, 700, 0x228B22); // Grass

                // Create graphics object for drawing the track road
                const trackGraphics = this.add.graphics();

                // Draw the outer track fill (road colour)
                trackGraphics.fillStyle(0x444444); // Road colour
                trackGraphics.beginPath();
                trackGraphics.moveTo(outerVertices[0].x, outerVertices[0].y);
                for (let i = 1; i < outerVertices.length; i++) {
                    trackGraphics.lineTo(outerVertices[i].x, outerVertices[i].y);
                }
                trackGraphics.closePath();
                trackGraphics.fillPath();

                // Draw the inner "grass" fill to create the road shape by covering the inner part
                trackGraphics.fillStyle(0x228B22); // Grass colour
                trackGraphics.beginPath();
                trackGraphics.moveTo(innerVertices[0].x, innerVertices[0].y);
                for (let i = 1; i < innerVertices.length; i++) {
                    trackGraphics.lineTo(innerVertices[i].x, innerVertices[i].y);
                }
                trackGraphics.closePath();
                trackGraphics.fillPath();

                // Create Matter.js static bodies for the physical track boundaries (walls).
                // `fromVertices(null, null, ...)` tells Matter.js to place the body at the centroid of the given vertices.
                // The `true` parameter `flagInternal` is crucial for concave shapes to ensure correct collisions.
                outerTrackBody = this.matter.add.fromVertices(null, null, outerVertices, {
                    isStatic: true,      // Makes the body unmovable
                    label: 'outerWall',  // Label for debugging/identification
                    friction: 0.1,       // Friction when car hits the wall
                    restitution: 0.9     // Bounciness when car hits the wall
                }, true); // `true` for flagInternal (important for concave decomposition)

                innerTrackBody = this.matter.add.fromVertices(null, null, innerVertices, {
                    isStatic: true,
                    label: 'innerWall',
                    friction: 0.1,
                    restitution: 0.9
                }, true); // `true` for flagInternal

                // Create Phaser.Geom.Polygon objects for the 'onTrack' check based on position.
                // These are used for the `contains` method in the update loop.
                outerTrackPolygon = new Phaser.Geom.Polygon(outerVertices);
                innerTrackPolygon = new Phaser.Geom.Polygon(innerVertices);
            }

            function update() {
                this.debugText.setPosition(this.cameras.main.scrollX + 10, this.cameras.main.scrollY + 10);
                
                const carPoint = new Phaser.Geom.Point(car.x, car.y);
                const onTrack = outerTrackPolygon.contains(carPoint.x, carPoint.y) && !innerTrackPolygon.contains(carPoint.x, carPoint.y);
                
                if (onTrack) {
                    car.setFrictionAir(normalFriction);
                    this.debugText.setText([`Speed: ${car.body.speed.toFixed(2)}`, 'On Track']);
                } else {
                    car.setFrictionAir(grassFriction);
                    this.debugText.setText([`Speed: ${car.body.speed.toFixed(2)}`, 'Off Track!']);
                }

                const acceleration = 0.005;
                const steering = 0.03;

                if (cursors.left.isDown) car.setAngularVelocity(-steering);
                else if (cursors.right.isDown) car.setAngularVelocity(steering);
                else car.setAngularVelocity(0);

                if (cursors.up.isDown) {
                    const force = new Phaser.Math.Vector2(Math.cos(car.rotation), Math.sin(car.rotation)).scale(acceleration);
                    car.applyForce(force);
                }

                if (car.body.speed > 0.1 && onTrack) {
                    this.emitter.start();
                } else {
                    this.emitter.stop();
                }
            }
        };
    </script>
</body>
</html>
